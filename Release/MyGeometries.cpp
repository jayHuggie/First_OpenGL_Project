//
//  MyGeometries.cpp - Fall 2022
//
//   Sets up and renders 
//     - the ground plane, and
//     - the surface of rotation
//   for the Math 155A project #6.
//


// Use the static library (so glew32.dll is not needed):
#define GLEW_STATIC
#include "GL/glew.h"
#include "GLFW/glfw3.h"

#include "LinearR3.h"		// Adjust path as needed.
#include "LinearR4.h"		// Adjust path as needed.
#include "MathMisc.h"       // Adjust path as needed

#include "MyGeometries.h"
#include "TextureProj.h"
#include "PhongData.h"
#include "RgbImage.h"
#include "GlGeomCylinder.h"
#include "GlGeomSphere.h"
#include "GlGeomTorus.h"

// **********************************
// Material to underlie a texture map.
// YOU MAY DEFINE A SECOND ONE OF THESE IF YOU WISH
// **********************************
phMaterial materialUnderTexture;

// **************************
// Information for loading textures
// **************************
const int NumTextures = 20;
unsigned int TextureNames[NumTextures];     // Texture names generated by OpenGL
const char* TextureFiles[NumTextures] = {
    "mintTile.bmp",
    "circle.bmp",
    "cola.bmp",
    "venus.bmp",
    "coin.bmp",
    "mercury.bmp",
    "BrickWallTexture.bmp",
    "floor.bmp",
    "whiteFace.bmp",
    "redFace.bmp",
    "blueFace.bmp",
    "orangeFace.bmp",
    "greenFace.bmp",
    "yellowFace.bmp",
    "silver.bmp",
    "hinoki.bmp",
    "navyTile.bmp",
    "tableMat.bmp",
    "brass.bmp",
    "poster.bmp"
};

// *******************************
// For spheres and a cylinder and a torus (Torus is currently not used.)
// *******************************
GlGeomSphere texSphere(4, 4);
GlGeomCylinder texCylinder(4, 4, 4);
GlGeomTorus texTorus(4, 4, 0.75);   

// ************************
// General data helping with setting up VAO (Vertex Array Objects)
//    and Vertex Buffer Objects.
// ***********************
const int NumObjects = 19;
const int iFloor = 0;
const int iCircularSurf = 1;
const int iWall = 2;           
const int whiteFace = 3;
const int redFace = 4;
const int blueFace = 5;
const int orangeFace = 6;
const int greenFace = 7;
const int yellowFace = 8;
const int leftWall = 9;
const int rightWall = 10;

const int topTable = 11;
const int frontTable = 12;
const int backTable = 13;
const int rightTable = 14;
const int leftTable = 15;
const int bottomTable = 16;

const int tableMat = 17;
const int poster = 18;

unsigned int myVBO[NumObjects];  // a Vertex Buffer Object holds an array of data
unsigned int myVAO[NumObjects];  // a Vertex Array Object - holds info about an array of vertex data;
unsigned int myEBO[NumObjects];  // a Element Array Buffer Object - holds an array of elements (vertex indices)

// ********************************************
// This sets up for texture maps. It is called only once
// ********************************************
void SetupForTextures()
{
    // This material goes under the textures.
    // IF YOU WISH, YOU MAY DEFINE MORE THAN ONE OF THESE FOR DIFFERENT GEOMETRIES
    materialUnderTexture.SpecularColor.Set(0.9, 0.9, 0.9);
    materialUnderTexture.AmbientColor.Set(0.9, 0.9, 0.9);
    materialUnderTexture.DiffuseColor.Set(0.7, 0.7, 0.7);       // Increase or decrease to adjust brightness
    materialUnderTexture.SpecularExponent = 40.0;

    // ***********************************************
    // Load texture maps
	// ***********************************************
    RgbImage texMap;

    glUseProgram(shaderProgramBitmap);
    glActiveTexture(GL_TEXTURE0);
    glGenTextures(NumTextures, TextureNames);
    for (int i = 0; i < NumTextures; i++) {
        texMap.LoadBmpFile(TextureFiles[i]);            // Read i-th texture from the i-th file.
        glBindTexture(GL_TEXTURE_2D, TextureNames[i]);  // Bind (select) the i-th OpenGL texture

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

        // Set best quality filtering.   Also see below for disabling mipmaps.
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);  // Requires that mipmaps be generated (see below)
        // You may also try GL_LINEAR_MIPMAP_NEAREST -- try looking at the wall from a 30 degree angle, and look for sweeping transitions.

        // Store the texture into the OpenGL texture named TextureNames[i]
        int textureWidth = texMap.GetNumCols();
        int textureHeight = texMap.GetNumRows();
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, texMap.ImageData());
 #if 1
        // Use mipmaps  (Best!)
        glGenerateMipmap(GL_TEXTURE_2D);
#else
        // Don't use mipmaps.  Try moving away from the brick wall a great distance
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
#endif

    }

    // Make sure that the shaderProgramBitmap uses the GL_TEXTURE_0 texture.
    glUseProgram(shaderProgramBitmap);
    glUniform1i(glGetUniformLocation(shaderProgramBitmap, "theTextureMap"), 0);
    glActiveTexture(GL_TEXTURE0);


}

// **********************
// This sets up geometries needed for 
//   (a) the floor (ground plane)
//   (b) the back wall
//   (c) the circular mesh
//   (d) two spheres
//   (e) one cylinder
//  It is called only once.
//  YOU NEED TO CHANGE THIS ONCE YOU ADD THE TEXTURE COORDINATES TO THE CIRCULAR SURFACE.
// **********************
void MySetupSurfaces() {

    texSphere.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texCylinder.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texTorus.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);

    // Initialize the VAO's, VBO's and EBO's for the ground plane, the back wall
    // and the surface of rotation. Gives them the "vertPos" location,
    // and the "vertNormal"  and the "vertTexCoords" locations in the shader program.
    // No data is loaded into the VBO's or EBO's for the circular surface until the "Remesh"
    //   routines is called

    glGenVertexArrays(NumObjects, &myVAO[0]);
    glGenBuffers(NumObjects, &myVBO[0]);
    glGenBuffers(NumObjects, &myEBO[0]);

    // For the Floor:
    // Allocate the needed Vertex Array Objects (VAO's),
    //      Vertex Buffer Objects (VBO's) and Element Array Buffer Objects (EBO's)
    // Since the floor has only four vertices.  Each vertex stores its
    //    position, its normal (0,1,0) and its (s,t)-coordinates.
    // YOU DO NOT NEED TO REMESH THE FLOOR (OR THE BACK WALL) SINCE WE USE PHONG INTERPOLATION
    float floorVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -10.0f, 0.0f, -10.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         10.0f, 0.0f, -10.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         10.0f, 0.0f,  10.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -10.0f, 0.0f,  10.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int floorElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iFloor]);
    glBindVertexArray(myVAO[iFloor]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(floorVerts), floorVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3*sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iFloor]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(floorElts), floorElts, GL_STATIC_DRAW);



    // FOR THE BACK WALL: ADD YOUR OWN CODE!! 
    // IT WILL BE SIMILAR TO THE FLOOR ABOVE.
    // YOU DO NOT NEED TO REMESH THE BACK WALL - ONE RECTANGLE (TWO TRIANGLES) IS ENOUGH
    float backfloorVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -10.0f, 10.0f, -10.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         10.0f, 10.0f, -10.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         10.0f, 0.0f,  -10.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -10.0f, 0.0f,  -10.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int backfloorElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall]);
    glBindVertexArray(myVAO[iWall]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(backfloorVerts), backfloorVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(backfloorElts), backfloorElts, GL_STATIC_DRAW);
    
    // Poster
    float posterVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -3.0f, 9.0f, -3.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         3.0f, 9.0f, -3.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         3.0f, 0.0f,  -3.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -3.0f, 0.0f,  -3.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int posterElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[poster]);
    glBindVertexArray(myVAO[poster]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(posterVerts), posterVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[poster]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(posterElts), posterElts, GL_STATIC_DRAW);

    // Right Wall
    float rightWallVerts[] = {
        // Position              // Normal                  // Texture coordinates
         10.0f, 10.0f, -10.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         10.0f, 10.0f, 10.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         10.0f, 0.0f,  10.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        10.0f, 0.0f,  -10.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int rightWallElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[rightWall]);
    glBindVertexArray(myVAO[rightWall]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(rightWallVerts), rightWallVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[rightWall]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(rightWallElts), rightWallElts, GL_STATIC_DRAW);

    // Left Wall
    float leftWallVerts[] = {
        // Position              // Normal                  // Texture coordinates
         -10.0f, 10.0f, -10.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         -10.0f, 10.0f, 10.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         -10.0f, 0.0f,  10.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
         -10.0f, 0.0f,  -10.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int leftWallElts[] = { 3, 0, 2, 1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[leftWall]);
    glBindVertexArray(myVAO[leftWall]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(leftWallVerts), leftWallVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[leftWall]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(leftWallElts), leftWallElts, GL_STATIC_DRAW);

    // 1. White Face
    float whiteFaceVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -1.0f, 0.0f, -1.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         1.0f, 0.0f, -1.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         1.0f, 0.0f,  1.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -1.0f, 0.0f,  1.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int whiteFaceElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[whiteFace]);
    glBindVertexArray(myVAO[whiteFace]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(whiteFaceVerts), whiteFaceVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[whiteFace]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(whiteFaceElts), whiteFaceElts, GL_STATIC_DRAW);


    // 2. Red Face
    float redFaceVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -1.0f, 0.0f, -1.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         1.0f, 0.0f, -1.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         1.0f, 0.0f,  1.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -1.0f, 0.0f,  1.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int redFaceElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[redFace]);
    glBindVertexArray(myVAO[redFace]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(redFaceVerts), redFaceVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[redFace]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(redFaceElts), redFaceElts, GL_STATIC_DRAW);


    // 3. Blue Face
    float blueFaceVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -1.0f, 0.0f, -1.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         1.0f, 0.0f, -1.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         1.0f, 0.0f,  1.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -1.0f, 0.0f,  1.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int blueFaceElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[blueFace]);
    glBindVertexArray(myVAO[blueFace]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(blueFaceVerts), blueFaceVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[blueFace]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(blueFaceElts), blueFaceElts, GL_STATIC_DRAW);

    // 4. Orange Face
    float orangeFaceVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -1.0f, 0.0f, -1.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         1.0f, 0.0f, -1.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         1.0f, 0.0f,  1.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -1.0f, 0.0f,  1.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int orangeFaceElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[orangeFace]);
    glBindVertexArray(myVAO[orangeFace]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(orangeFaceVerts), orangeFaceVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[orangeFace]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(orangeFaceElts), orangeFaceElts, GL_STATIC_DRAW);

    // 5. Green Face
    float greenFaceVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -1.0f, 0.0f, -1.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         1.0f, 0.0f, -1.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         1.0f, 0.0f,  1.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -1.0f, 0.0f,  1.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int greenFaceElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[greenFace]);
    glBindVertexArray(myVAO[greenFace]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(greenFaceVerts), greenFaceVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[greenFace]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(greenFaceElts), greenFaceElts, GL_STATIC_DRAW);

    // 6. Yellow Face
    float yellowFaceVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -1.0f, 0.0f, -1.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         1.0f, 0.0f, -1.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         1.0f, 0.0f,  1.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -1.0f, 0.0f,  1.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int yellowFaceElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[yellowFace]);
    glBindVertexArray(myVAO[yellowFace]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(yellowFaceVerts), yellowFaceVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[yellowFace]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(yellowFaceElts), yellowFaceElts, GL_STATIC_DRAW);

    // 1. Top Table
    float topTableVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -3.0f, 3.0f, -3.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         3.0f, 3.0f, -3.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         3.0f, 0.0f,  -3.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -3.0f, 0.0f,  -3.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int topTableElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[topTable]);
    glBindVertexArray(myVAO[topTable]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(topTableVerts), topTableVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[topTable]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(topTableElts), topTableElts, GL_STATIC_DRAW);


    // 2. Front Table

    float frontTableVerts[] = {
        // Position              // Normal                  // Texture coordinates
         3.0f, 0.5f, -3.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         3.0f, 0.5f, 3.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         3.0f, 0.0f,  3.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        3.0f, 0.0f,  -3.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int frontTableElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[frontTable]);
    glBindVertexArray(myVAO[frontTable]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(frontTableVerts), frontTableVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[frontTable]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(frontTableElts), frontTableElts, GL_STATIC_DRAW);

    // 3. Back Table

    float backTableVerts[] = {
        // Position              // Normal                  // Texture coordinates
         3.0f, 0.5f, -3.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         3.0f, 0.5f, 3.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         3.0f, 0.0f,  3.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        3.0f, 0.0f,  -3.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int backTableElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[backTable]);
    glBindVertexArray(myVAO[backTable]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(backTableVerts), backTableVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[backTable]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(backTableElts), backTableElts, GL_STATIC_DRAW);

    // 4. Right Table
    float rightTableVerts[] = {
        // Position              // Normal                  // Texture coordinates
         3.0f, 0.5f, -3.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         3.0f, 0.5f, 0.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         3.0f, 0.0f,  0.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        3.0f, 0.0f,  -3.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int rightTableElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[rightTable]);
    glBindVertexArray(myVAO[rightTable]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(rightTableVerts), rightTableVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[rightTable]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(rightTableElts), rightTableElts, GL_STATIC_DRAW);

    // 4. Left Table
    float leftTableVerts[] = {
        // Position              // Normal                  // Texture coordinates
         3.0f, 0.5f, -3.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         3.0f, 0.5f, 0.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         3.0f, 0.0f,  0.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        3.0f, 0.0f,  -3.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int leftTableElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[leftTable]);
    glBindVertexArray(myVAO[leftTable]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(leftTableVerts), leftTableVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[leftTable]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(leftTableElts), leftTableElts, GL_STATIC_DRAW);

    // 6. Bottom Table
    float bottomTableVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -3.0f, 3.0f, -3.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         3.0f, 3.0f, -3.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         3.0f, 0.0f,  -3.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -3.0f, 0.0f,  -3.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int bottomTableElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[bottomTable]);
    glBindVertexArray(myVAO[bottomTable]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(bottomTableVerts), bottomTableVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[bottomTable]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(bottomTableElts), bottomTableElts, GL_STATIC_DRAW);
  
    /* 
    // Table mat
    float tableMatVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -1.0f, 1.0f, -1.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         1.0f, 1.0f, -1.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         1.0f, 0.0f,  -1.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -1.0f, 0.0f,  -1.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int tableMatElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[tableMat]);
    glBindVertexArray(myVAO[tableMat]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(tableMatVerts), tableMatVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[tableMat]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(tableMatElts), tableMatElts, GL_STATIC_DRAW);
    */
    check_for_opengl_errors();      // Watch the console window for error messages!
}


void MyRemeshGeometries() 
{
// IT IS NOT NECESSARY TO REMESH EITHER THE FLOOR OR THE BACK WALL
// YOU DO NOT NEED TO CHANGE THIS FOR PROJECT #6.

    //SamsRemeshCircularSurf();
    texSphere.Remesh(meshRes, meshRes);
    texCylinder.Remesh(meshRes, meshRes, meshRes);
    texTorus.Remesh(meshRes, meshRes );

    check_for_opengl_errors();      // Watch the console window for error messages!
}

// **********************************************
// MODIFY THIS ROUTINE TO RENDER THE FLOOR, THE BACK WALL,
//    AND THE SPHERES AND THE CYLINDER. -- WITH TEXTURES
// **********************************************

void MyRenderGeometries() {
    phMaterial Material;
    float matEntries[16];       // Temporary storage for floats

    LinearMapR4 matDemo = viewMatrix;
    // ******
    // Render the Floor - using a procedural texture map
    // ******
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iFloor]);                // Select the floor VAO (Vertex Array Object)
    //materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    Material.EmissiveColor.Set(0.0f, 0.0f, 0.0f);
    Material.AmbientColor.Set(0.3f, 0.3f, 0.3f);
    Material.DiffuseColor.Set(0.7f, 0.7f, 0.7f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.SpecularExponent = 40.0;
    Material.LoadIntoShaders();

    glBindTexture(GL_TEXTURE_2D, TextureNames[0]);     // Choose image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);    
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }



    // ************ 
    // Render the back wall
    //  YOU MUST WRITE THIS. IT WILL BE SIMILAR TO THE FLOOR ABOVE. 
    //  BUT USE A BITMAP (shaderProgramBitmap) INSTEAD OF A PROCEDURAL TEXTURE.
    
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iWall]);                // Select the floor VAO (Vertex Array Object)
    //materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    Material.EmissiveColor.Set(0.0f, 0.0f, 0.0f);
    Material.AmbientColor.Set(0.3f, 0.3f, 0.3f);
    Material.DiffuseColor.Set(0.7f, 0.7f, 0.7f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    //Material.SpecularExponent = 40.0;
    Material.LoadIntoShaders();

    glBindTexture(GL_TEXTURE_2D, TextureNames[16]);     // Choose image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }

    // Poster
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, 2.0, -6.999);
    //matDemo.Mult_glRotate(PI/2.0, 0.0, 0.0, 1.0);
    matDemo.Mult_glScale(0.8, 0.8, 1.0);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);

    Material.EmissiveColor.Set(0.0f, 0.0f, 0.0f);
    Material.AmbientColor.Set(0.3f, 0.3f, 0.3f);
    Material.DiffuseColor.Set(0.7f, 0.7f, 0.7f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.LoadIntoShaders();
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[poster]);                // Select the floor VAO (Vertex Array Object)
    //materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color



    glBindTexture(GL_TEXTURE_2D, TextureNames[19]);     // Choose image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }

    // Right Wall
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[rightWall]);                // Select the floor VAO (Vertex Array Object)
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    Material.EmissiveColor.Set(0.0f, 0.0f, 0.0f);
    Material.AmbientColor.Set(0.3f, 0.3f, 0.3f);
    Material.DiffuseColor.Set(0.7f, 0.7f, 0.7f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.SpecularExponent = 40.0;
    Material.LoadIntoShaders();

    glBindTexture(GL_TEXTURE_2D, TextureNames[16]);     // Choose image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }

    // Left Wall
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[leftWall]);                // Select the floor VAO (Vertex Array Object)
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    Material.EmissiveColor.Set(0.0f, 0.0f, 0.0f);
    Material.AmbientColor.Set(0.3f, 0.3f, 0.3f);
    Material.DiffuseColor.Set(0.7f, 0.7f, 0.7f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.SpecularExponent = 40.0;
    Material.LoadIntoShaders();

    glBindTexture(GL_TEXTURE_2D, TextureNames[16]);     // Choose image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }
    // *************
    // Render two spheres and a cylinder
    // YOU MUST MODIFY THE CODE BELOW, AND ADD TEXTURES TO THE SPHERE AND THE CAPS OF THE CYLINDER.

    // Render a sphere with a earth image texture map
    //  YOU DO NOT NEED TO MODIFY THIS SPHERE OR ITS TEXTURE MAP
    


    /* Sphere
    matDemo.Mult_glScale(1.0, 1.0, 1.0);
    matDemo.Mult_glTranslate(-3.5, currentTime, 0.4);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[3]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    */


// 1. Front left Cylinder
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-5.0, 1.3, 2.1);
    //matDemo.Mult_glRotate(PI/2.0, 0.0, 0.0, 1.0);
    matDemo.Mult_glScale(0.15, 1.3, 0.15);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[14]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    // 2. Back left Cylinder
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-5.0, 1.3, -2.3);
    //matDemo.Mult_glRotate(PI/2.0, 0.0, 0.0, 1.0);
    matDemo.Mult_glScale(0.15, 1.3, 0.15);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[14]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!


    // 3. Front right Cylinder
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(5.0, 1.3, 2.1);
    //matDemo.Mult_glRotate(PI/2.0, 0.0, 0.0, 1.0);
    matDemo.Mult_glScale(0.15, 1.3, 0.15);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[14]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!
    
                                                          
    // 4. Back Right Cylinder
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(5.0, 1.3, -2.3);
    //matDemo.Mult_glRotate(PI/2.0, 0.0, 0.0, 1.0);
    matDemo.Mult_glScale(0.15, 1.3, 0.15);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[14]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

       // 1. Stand_1
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(3.4, 5.2, 1.0);
    matDemo.Mult_glRotate(PI/6.0, 0.0, 0.0, 1.0);
    matDemo.Mult_glScale(0.4, 2.9, 0.2);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[18]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[18]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[18]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!
    
                                                          
     // Renders a textured torus in the back left corner.
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, 7.8, 1.0);
    matDemo.Mult_glScale(1.3, 0.35, 0.7);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[18]);     // Choose texture
    glUniform1i(applyTextureLocation, true);            // Enable applying the texture!
    texTorus.Render();                                  // Render the torus
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
        
    // 1. Top Table
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, 6.0, 3.0);        // CHANGE For different Face!!
    matDemo.Mult_glRotate(3.0 * PI / 2.0, 1.0, 0.0, 0.0);
    matDemo.Mult_glScale(2.0, 2.0, 1.0);
    matDemo.DumpByColumns(matEntries);

    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    //Material.EmissiveColor.Set(0.0f, 0.0f, 0.0f);
    Material.AmbientColor.Set(1.0f, 1.0f, 1.0f);
    Material.DiffuseColor.Set(1.0f, 1.0f, 1.0f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.SpecularExponent = 40.0;
    spinMode = true;
                                                         // CRAZY LIGHT ANIMATION!!!!
    myLights[2].AmbientColor.Set(1.0-currentTime, currentTime, 2.0 * min(currentTime, 1 - currentTime));
    
    myLights[2].DiffuseColor.Set(1.0-currentTime, currentTime, 2.0 * min(currentTime, 1 - currentTime));
    myLights[2].SpecularColor.Set(0.8, 0.8, 0.8);
    LoadAllLights();
    Material.LoadIntoShaders();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[topTable]);                // Select the floor VAO (Vertex Array Object)
    glBindTexture(GL_TEXTURE_2D, TextureNames[17]);     // Choose image texture
    glUniform1i(applyTextureLocation, true);

    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }

    // 2. Front Table
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, 2.5, 9.0);        // CHANGE For different Face!!
    matDemo.Mult_glRotate(PI / 2.0, 0.0, 1.0, 0.0);
    matDemo.Mult_glScale(2.0, 1.0, 2.0);
    matDemo.DumpByColumns(matEntries);

    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    //Material.EmissiveColor.Set(0.0f, 0.0f, 0.0f);
    Material.AmbientColor.Set(0.6f, 0.6f, 0.6f);
    Material.DiffuseColor.Set(0.9f, 0.9f, 0.9f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.SpecularExponent = 40.0;
    Material.LoadIntoShaders();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[frontTable]);                // Change!!
    glBindTexture(GL_TEXTURE_2D, TextureNames[15]);     // Choose image texture
    glUniform1i(applyTextureLocation, true);

    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }
    // 3. Back Table
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, 2.5, -9.0);        // CHANGE For different Face!!
    matDemo.Mult_glRotate(3 * PI / 2.0, 0.0, 1.0, 0.0);
    matDemo.Mult_glScale(2.0, 1.0, 2.0);
    matDemo.DumpByColumns(matEntries);

    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    //Material.EmissiveColor.Set(0.0f, 0.0f, 0.0f);
    Material.AmbientColor.Set(0.6f, 0.6f, 0.6f);
    Material.DiffuseColor.Set(0.9f, 0.9f, 0.9f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.SpecularExponent = 40.0;
    Material.LoadIntoShaders();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[backTable]);                // Change!!
    glBindTexture(GL_TEXTURE_2D, TextureNames[15]);     // Choose image texture
    glUniform1i(applyTextureLocation, true);

    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }

    // 4. Right Table
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-12.0, 2.5, 3.0);        // CHANGE For different Face!!
    //matDemo.Mult_glRotate(3 * PI / 2.0, 0.0, 1.0, 0.0);
    matDemo.Mult_glScale(2.0, 1.0, 2.0);
    matDemo.DumpByColumns(matEntries);

    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    //Material.EmissiveColor.Set(0.0f, 0.0f, 0.0f);
    Material.AmbientColor.Set(0.6f, 0.6f, 0.6f);
    Material.DiffuseColor.Set(0.9f, 0.9f, 0.9f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.SpecularExponent = 40.0;
    Material.LoadIntoShaders();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[rightTable]);                // Change!!
    glBindTexture(GL_TEXTURE_2D, TextureNames[15]);     // Choose image texture
    glUniform1i(applyTextureLocation, true);

    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }

    // 5. Left Table   ----> turned right after scaling
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(12.0, 2.5, -3.0);        // CHANGE For different Face!!
    matDemo.Mult_glRotate(PI, 0.0, 1.0, 0.0);
    matDemo.Mult_glScale(2.0, 1.0, 2.0);
    matDemo.DumpByColumns(matEntries);

    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    //Material.EmissiveColor.Set(0.0f, 0.0f, 0.0f);
    Material.AmbientColor.Set(0.6f, 0.6f, 0.6f);
    Material.DiffuseColor.Set(0.9f, 0.9f, 0.9f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.SpecularExponent = 40.0;
    Material.LoadIntoShaders();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[leftTable]);                // Change!!
    glBindTexture(GL_TEXTURE_2D, TextureNames[15]);     // Choose image texture
    glUniform1i(applyTextureLocation, true);

    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }
    // 6. Bottom Table
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, -0.5, -3.0);        // CHANGE For different Face!!
    matDemo.Mult_glRotate( PI / 2.0, 1.0, 0.0, 0.0);
    matDemo.Mult_glScale(2.0, 2.0, 1.0);
    matDemo.DumpByColumns(matEntries);

    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    //Material.EmissiveColor.Set(0.0f, 0.0f, 0.0f);
    Material.AmbientColor.Set(0.6f, 0.6f, 0.6f);
    Material.DiffuseColor.Set(0.9f, 0.9f, 0.9f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.SpecularExponent = 40.0;
    Material.LoadIntoShaders();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[bottomTable]);                // Change!!
    glBindTexture(GL_TEXTURE_2D, TextureNames[15]);     // Choose image texture
    glUniform1i(applyTextureLocation, true);

    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }

    // 1. White Face
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, 5.5, 1.0);        // CHANGE For different Face!!
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    
    Material.EmissiveColor.Set(0.3f, 0.4f, 0.3f);
    Material.AmbientColor.Set(0.3f, 0.3f, 0.3f);
    Material.DiffuseColor.Set(0.7f, 0.7f, 0.7f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.SpecularExponent = 40.0;
    Material.LoadIntoShaders();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[whiteFace]);                // Select the floor VAO (Vertex Array Object) // CHANGE
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // CHANGE For different Face!!
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
                                  
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }

    // 2. Red Face
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-1.0, 4.5, 1.0);        // CHANGE For different Face!!
    matDemo.Mult_glRotate(PI / 2.0, 0.0, 0.0, 1.0);
    matDemo.DumpByColumns(matEntries);           
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    Material.EmissiveColor.Set(0.3f, 0.4f, 0.3f);
    Material.AmbientColor.Set(0.3f, 0.3f, 0.3f);
    Material.DiffuseColor.Set(0.7f, 0.7f, 0.7f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.SpecularExponent = 40.0;
    Material.LoadIntoShaders();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[redFace]);                // Select the floor VAO (Vertex Array Object) // CHANGE!!
    glBindTexture(GL_TEXTURE_2D, TextureNames[9]);     // CHANGE For different Face!! (8 + x)!!
    glUniform1i(applyTextureLocation, true);        

    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }

    // 3. Blue Face
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, 4.5, 2.0);        // CHANGE For different Face!!
    matDemo.Mult_glRotate(PI / 2.0, 1.0, 0.0, 0.0);
    matDemo.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    Material.EmissiveColor.Set(0.3f, 0.4f, 0.3f);
    Material.AmbientColor.Set(0.3f, 0.3f, 0.3f);
    Material.DiffuseColor.Set(0.7f, 0.7f, 0.7f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.SpecularExponent = 40.0;
    Material.LoadIntoShaders();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[blueFace]);                // Select the floor VAO (Vertex Array Object) // CHANGE!!
    glBindTexture(GL_TEXTURE_2D, TextureNames[10]);     // CHANGE For different Face!! (8 + x)!!
    glUniform1i(applyTextureLocation, true);

    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }

    // 4. Orange Face
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(1.0, 4.5, 1.0);        // CHANGE For different Face!!
    matDemo.Mult_glRotate(3.0 * PI / 2.0, 0.0, 0.0, 1.0);
    matDemo.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    Material.EmissiveColor.Set(0.3f, 0.4f, 0.3f);
    Material.AmbientColor.Set(0.3f, 0.3f, 0.3f);
    Material.DiffuseColor.Set(0.7f, 0.7f, 0.7f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.SpecularExponent = 40.0;
    Material.LoadIntoShaders();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[orangeFace]);                // Select the floor VAO (Vertex Array Object) // CHANGE!!
    glBindTexture(GL_TEXTURE_2D, TextureNames[11]);     // CHANGE For different Face!! (8 + x)!!
    glUniform1i(applyTextureLocation, true);

    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }

    // 5. Green Face
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, 4.5, 0.0);        // CHANGE For different Face!!
    matDemo.Mult_glRotate(3.0 * PI / 2.0, 1.0, 0.0, 0.0);
    matDemo.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    Material.EmissiveColor.Set(0.3f, 0.4f, 0.3f);
    Material.AmbientColor.Set(0.3f, 0.3f, 0.3f);
    Material.DiffuseColor.Set(0.7f, 0.7f, 0.7f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.SpecularExponent = 40.0;
    Material.LoadIntoShaders();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[greenFace]);                // Select the floor VAO (Vertex Array Object) // CHANGE!!
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // CHANGE For different Face!! (8 + x)!!
    glUniform1i(applyTextureLocation, true);

    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }

    // 6. Yellow Face
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, 3.5, 1.0);        // CHANGE For different Face!!
    matDemo.Mult_glRotate(PI, 1.0, 0.0, 0.0);
    matDemo.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    Material.EmissiveColor.Set(0.3f, 0.4f, 0.3f);
    Material.AmbientColor.Set(0.3f, 0.3f, 0.3f);
    Material.DiffuseColor.Set(0.7f, 0.7f, 0.7f);
    Material.SpecularColor.Set(0.9, 0.9, 0.9);
    Material.SpecularExponent = 40.0;
    Material.LoadIntoShaders();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[greenFace]);                // Select the floor VAO (Vertex Array Object) // CHANGE!!
    glBindTexture(GL_TEXTURE_2D, TextureNames[13]);     // CHANGE For different Face!! (8 + x)!!
    glUniform1i(applyTextureLocation, true);

    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }


    check_for_opengl_errors();      // Watch the console window for error messages!
}




